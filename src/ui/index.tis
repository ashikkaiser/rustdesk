if (is_osx) view.windowBlurbehind = #light;
stdout.println("current platform:", OS);
stdout.println("is_xfce: ", is_xfce);

// html min-width, min-height not working on mac, below works for all
view.windowMinSize = (scaleIt(250), scaleIt(250));
view.windowMaxSize = (scaleIt(250), scaleIt(250));

var app;
var tmp = handler.get_connect_status();
var connect_status = tmp[0];
var service_stopped = handler.get_option("stop-service") == "Y";
var using_public_server = handler.using_public_server();
var software_update_url = "";
var key_confirmed = tmp[1];
var system_error = "";

var svg_menu = <svg #menu viewBox="0 0 512 512">
	<circle cx="256" cy="256" r="64"/>
	<circle cx="256" cy="448" r="64"/>
	<circle cx="256" cy="64" r="64"/>
</svg>;

var my_id = handler.get_id();
function get_id() {
  my_id = handler.get_id();
  return my_id;
}

class ConnectStatus: Reactor.Component {
    function render() {
        return
            <div .connect-status>
                <span class={"connect-status-icon connect-status" + (service_stopped ? 0 : connect_status)} />
                {this.getConnectStatusStr()}
                {service_stopped ? <span .link #start-service>{translate('Start service')}</span> : ""}
            </div>;
    }

    function getConnectStatusStr() {
        if (service_stopped) {
            return translate("Service is not running");
        } else if (connect_status == -1) {
            return translate('not_ready_status');
        } else if (connect_status == 0) {
            return translate('connecting_status');
        }
        if (!handler.using_public_server()) return translate('Ready');
        return <span>{translate("Ready")}, <span .link #setup-server>{translate("setup_server_tip")}</span></span>;
    }

    event click $(#start-service) () {
        handler.set_option("stop-service", "");
    }

    event click $(#setup-server) () {
        handler.open_url("https://cloudydesk.com/blog/id-relay-set/");
    }
}



function getUserName() {
    try {
        return JSON.parse(handler.get_local_option("user_info")).name;
    } catch(e) {}
    return '';
}

function updateTheme() {
    var root_element = self;
    if (handler.get_option("allow-darktheme") == "Y") {
        // enable dark theme
        root_element.attributes.toggleClass("darktheme", true);
    } else {
        // disable dark theme
        root_element.attributes.toggleClass("darktheme", false);
    }
}



function editDirectAccessPort() {
    var p0 = handler.get_option('direct-access-port');
    var port = p0 ? <input|text name='port' value={p0} /> :
                    <input|text name='port' novalue={21118} />;
    msgbox("custom-direct-access-port", translate('Direct IP Access Settings'), <div .form .set-password>
            <div><span style="width: 60px;">{translate('Port')}:</span>{port}</div>
        </div>, "", function(res=null) {
        if (!res) return;
        var p = (res.port || '').trim();
        if (p) {
            p = p.toInteger();
            if (!(p > 0)) {
                return translate("Invalid port");
            }
            p = p + '';
        }
        if (p != p0) handler.set_option('direct-access-port', p);
      });
}

class App: Reactor.Component
{
    function this() {
        app = this;
    }

    function render() {
        var is_can_screen_recording = handler.is_can_screen_recording(false);
        return
            <div .app>
                    <div .left-pane>
                    <div>
                        <div .title>{translate('Your Desktop')}</div>
                        <div .lighter-text>{translate('desk_tip')}</div>
                        <div .your-desktop>
                            <input type="text" readonly value={formatId(get_id())}/>
                        </div>
                    </div>
                    {!is_win || handler.is_installed() ? "": <InstallMe />}
                    {!service_stopped && is_can_screen_recording && handler.is_process_trusted(false) && handler.is_installed() && !handler.is_installed_daemon(false) ? <InstallDaemon /> : ""}
                    {system_error ? <SystemError /> : ""}

                     <ConnectStatus @{this.connect_status} />
                </div>
            </div>;
    } 
}

class InstallMe: Reactor.Component {
    function render() {
        return <div .install-me>
            <div><button #install-me .button>{translate('Install')}</button></div>
        </div>;
    }

    event click $(#install-me) {
        handler.goto_install();
    }
}



class SystemError: Reactor.Component {
    function render() {
        return <div .install-me>
            <div>{system_error}</div>
        </div>;
    }
}




class InstallDaemon: Reactor.Component {
    function render() {
        return <div .install-me>
            <span />
            <div>{translate('install_daemon_tip')}</div>
            <div #install-me.link>{translate('Install')}</div>
        </div>;
    }

    event click $(#install-me) {
        handler.is_installed_daemon(true);
    }
}






class ID: Reactor.Component {
    function render() {
        return <input type="text" #remote_id .outline-focus novalue={translate("Enter Remote ID")}
        value={formatId(handler.get_remote_id())} />;
    }

    // https://github.com/c-smile/sciter-sdk/blob/master/doc/content/sciter/Event.htm
    event change {
        var fid = formatId(this.value);
        var d = this.value.length - (this.old_value || "").length;
        this.old_value = this.value;
        var start = this.xcall(#selectionStart) || 0;
        var end = this.xcall(#selectionEnd);
        if (fid == this.value || d <= 0 || start != end) {
            return;
        }
        // fix Caret position
        this.value = fid;
        var text_after_caret = this.old_value.substr(start);
        var n = fid.length - formatId(text_after_caret).length;
        this.xcall(#setSelection, n, n);
    }
}

var reg = /^\d+$/;
function formatId(id) {
    id = id.replace(/\s/g, "");
    if (reg.test(id) && id.length > 3) {
        var n = id.length;
        var a = n % 3 || 3;
        var new_id = id.substr(0, a);
        for (var i = a; i < n; i += 3) {
            new_id += " " + id.substr(i, 3);
        }
        return new_id;
    }
    return id;
}



$(body).content(<div style="size:*"><App /><div #msgbox /></div>);

function self.closing() {
    var (x, y, w, h) = view.box(#rectw, #border, #screen);
    handler.closing(x, y, w, h);
    return true;
}

function self.ready() {
    var r = handler.get_size();
    if (isReasonableSize(r) && r[2] > 0) {
        var (sx, sy, sw, sh) = view.screenBox(#workarea, #rectw);
        if (r[2] >= sw && r[3] >= sh) {
            self.timer(1ms, function() { view.windowState = View.WINDOW_MAXIMIZED; });
        } else {
            view.move(r[0], r[1], r[2], r[3]);
        }
    } else {
        centerize(scaleIt(200), scaleIt(450));
    }
    if (!handler.get_remote_id()) {
        view.focus = $(#remote_id);
    }
    updateTheme();
}

function checkConnectStatus() {
    handler.check_mouse_time(); // trigger connection status updater
    self.timer(1s, function() {
        var tmp = handler.get_option("stop-service") == "Y";
        if (tmp != service_stopped) {
            service_stopped = tmp;
            app.update();
        }
        tmp = handler.using_public_server();
        if (tmp != using_public_server) {
            using_public_server = tmp;
            app.connect_status.update();
        }
        tmp = handler.get_connect_status();
        if (tmp[0] != connect_status) {
            connect_status = tmp[0];
            app.connect_status.update();
        }
        if (tmp[1] != key_confirmed) {
            key_confirmed = tmp[1];
            app.update();
        }
        if (tmp[2] && tmp[2] != my_id) {
            stdout.println("id updated");
            app.update();
        }
        tmp = handler.get_error();
        if (system_error != tmp) {
            system_error = tmp;
            app.update();
        }
        tmp = handler.get_software_update_url();
        if (tmp != software_update_url) {
            software_update_url = tmp;
            app.update();
        }
        if (handler.recent_sessions_updated()) {
            stdout.println("recent sessions updated");
            app.update();
        }
        check_if_overlay();
        checkConnectStatus();    
    });                          
}                                
                                 
var enter = false;               
function self.onMouse(evt) {     
    switch(evt.type) {           
    case Event.MOUSE_ENTER:    
        enter = true;
        break;
    case Event.MOUSE_LEAVE:
        enter = false;
        break;
    }
}

function check_if_overlay() {
    // Overlay functionality disabled for simplified interface
}

checkConnectStatus();


function getHttpHeaders() {
    return "Authorization: Bearer " + handler.get_local_option("access_token");
}

